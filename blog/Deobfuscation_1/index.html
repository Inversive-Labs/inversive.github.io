<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tales Of Binary Deobfuscation - Inversive Labs</title>
    <link rel="shortcut icon" href="/images/favicon.ico" title="Favicon" />
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@100;200;300;400;500;600&display=swap" rel="stylesheet">
    
    <!-- Main stylesheet -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Scroll progress indicator -->
    <div class="scroll-indicator">
        <div class="scroll-progress"></div>
    </div>

    <!-- Background removed -->

    <header>
    <nav class="container">
        <div class="logo-container">
            <a href="/index.html"><img src="/images/logo.svg" width="250"></a>
        </div>
        
        <!-- Hamburger Button for Mobile -->
        <button class="hamburger" aria-label="Toggle menu">
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
        </button>
        
        <ul class="nav-links">
            <li><a href="/index.html#about" >About</a></li>
            <li><a href="/index.html#team" >Team</a></li>
            <li>
                <a href="/services/" >Services</a>
            </li>
            <li class="has-dropdown">
                <a href="/portfolio/" >Portfolio</a>
                <div class="nav-dropdown">
                    <a href="/portfolio/#smart-contract-audits" class="nav-dropdown-link">Audits</a>
                    <a href="/portfolio/#Testing-Campaign" class="nav-dropdown-link">Testing</a>
                    <a href="/portfolio/#smart-contract-development" class="nav-dropdown-link">Development</a>
                    <a href="/portfolio/#tooling-development" class="nav-dropdown-link">Tooling</a>
                    <a href="/portfolio/#cve-advisories" class="nav-dropdown-link">Advisories</a>
                    <a href="/portfolio/#research-papers" class="nav-dropdown-link">Papers</a>
                    <a href="/portfolio/#grants-funding" class="nav-dropdown-link">Grants</a>
                </div>
            </li>
            <li><a href="/blog/" class="active">Blog</a></li>
            <li><a href="/index.html#contact" >Contact</a></li>
        </ul>
    </nav>
</header>

    <main>
        <script>
document.body.classList.add('post-page');
</script>

<div class="container">
    <article style="max-width: 900px; margin: 0 auto; padding: 5rem 2rem; position: relative;">
        <!-- Enhanced title with gradient effect -->
        <h1 style="
            background: linear-gradient(90deg, #ffffff 0%, #10ebff 50%, #ffffff 100%);
            background-size: 200% 100%;
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            animation: shimmerTitle 3s ease-in-out infinite;
            font-size: 2.5rem;
            font-weight: 800;
            font-family: 'Raleway', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            letter-spacing: -0.025em;
            margin-bottom: 1.5rem;
            text-align: center;
            padding-top: 3rem;
            margin-top: 2rem;
        ">Tales Of Binary Deobfuscation</h1>
        
        <!-- Enhanced post meta -->
        <div style="
            color: #35e4f4;
            position: relative;
            font-size: 1rem;
            font-weight: 500;
            font-family: 'Raleway', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            text-align: center;
            margin-bottom: 3rem;
            padding-bottom: 1rem;
        ">
            March 03, 2020
             • ulexec
            <div style="
                content: '';
                position: absolute;
                bottom: -1px;
                left: 50%;
                transform: translateX(-50%);
                width: 60px;
                height: 2px;
                background: linear-gradient(90deg, transparent, #35e4f4, transparent);
                border-radius: 1px;
            "></div>
        </div>
        
        <!-- Enhanced content area -->
        <div style="
            color: #d1d5db;
            line-height: 1.7;
            font-size: 1.1rem;
            text-align: left;
        ">
            <p>This article is a review of Yuma Kurogome’s course on <a href="https://github.com/malrev/ABD">Advance Binary Deobfuscation</a></p>

<h3 id="introduction">Introduction</h3>

<p>There are close to 31 known <a href="https://mediatum.ub.tum.de/doc/1367533/1367533.pdf">code transformations</a>. However, In this article we will focus on grouping these transformation in categories based on their behavior, and we will cover some of the most relevant techniques today on a conceptual point of view.
We will be also covering practical approaches to the aforementioned techniques using the reverse engineering framework MIASM (0.1.3.dev39).</p>

<p>Despite the large number of transformations, obfuscation techniques can be group up into 3 different categories:</p>

<ul>
  <li>Confusion oriented:
    <ul>
      <li>Unreachable Code Insertion</li>
      <li>Dead Code Insertion</li>
    </ul>
  </li>
  <li>Syntax Modification
    <ul>
      <li>Instruction Substitution</li>
      <li>Constant Folding/Unfolding</li>
    </ul>
  </li>
  <li>Semantic Modification
    <ul>
      <li>Opaque Predicates</li>
      <li>Range Dividers</li>
      <li>Virtualization</li>
      <li>Control Flow Flattening</li>
    </ul>
  </li>
</ul>

<p>We will be discussing each of these techniques on a conceptual level, although we will be also covering practical examples.
The purpose of this article is to crystallize concepts instead of being a strict technical reference, although further technical reading will be linked all throughout the article along with practical implementations on how to remediate some of these techniques.</p>

<h3 id="unreachabledead-code-constant-unfolding-and-instruction-substitution">Unreachable/Dead Code, Constant Unfolding and Instruction Substitution</h3>

<p>In this section we will be covering 3 different transformations which have a close correlation between one another, and consequently a similar approach for circumvention.</p>

<ul>
  <li><strong>Unreachable Code</strong>: is defined as inserted code into a target application which is never going to be executed, serving the purpose of an unexpensive way of distracting the analyst for a few minutes.
an example of Junk code is the following:
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="nf">jz</span> <span class="nv">loc_key1</span>      <span class="c1">; lets imagine this conditional branch is not really conditional</span>
<span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>     <span class="c1">; * this will never execute</span>
<span class="nf">pushf</span> 	         <span class="c1">; *</span>
<span class="nf">pop</span> <span class="nb">ebx</span>          <span class="c1">; *</span>
<span class="nf">and</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0x100</span>   <span class="c1">; *</span>
<span class="nf">cmp</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0x100</span>   <span class="c1">; *</span>
<span class="nf">je</span> <span class="nv">loc_key2</span>      <span class="c1">; *</span>
<span class="nl">loc_key1:</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li><strong>Dead Code</strong>: is defined as inserted code into a target application which, although it may be executed, it does not change the original control flow of the program.
Again this technique’s pupose is to just confuse the analyst to make him/her spend a bit more time understanding the purpose of the aforementioned instructions.
The following is an example:</li>
</ul>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mh">0xdeadc00d</span>  <span class="c1">; * this specific instruction is deadcode</span>
<span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">arg_4</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">arg_0</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mi">5</span>           <span class="c1">; * edx gets overriden here, also deadcode</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">var_4</span><span class="p">],</span> <span class="nb">ecx</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">var_8</span><span class="p">],</span> <span class="nb">eax</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><strong>Instruction Substitution</strong>: defined as to replace a given set of instructions with another more complex set of instructions with identical semantic meaning. This kind of techniques have been heavely employed by metamorphic code engines in the past and may highly affect the legibility of the affected code.
Lets imagine that originally we have the following set of instructions:</li>
</ul>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">var_8</span><span class="p">]</span>
<span class="nf">add</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">var_C</span><span class="p">]</span>
<span class="nf">add</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">var_10</span><span class="p">]</span>
<span class="nf">add</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">var_4</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This set of instruction can be transform to the following one, being much harder to interpret and understand having the same semantic meaning:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">var_C</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">var_10</span><span class="p">]</span>
<span class="nf">sub</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">2598A32Bh</span>
<span class="nf">add</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">edx</span>
<span class="nf">add</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">2598A32Bh</span>
<span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">var_4</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">ecx</span>
<span class="nf">sub</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">eax</span>
<span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">ecx</span>
<span class="nf">sub</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">edx</span>
<span class="nf">add</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">eax</span>
<span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">ecx</span>
<span class="nf">sub</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">esi</span>
<span class="nf">mov</span> <span class="nb">edx</span><span class="p">,[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">var_8</span><span class="p">]</span>
<span class="nf">sub</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">edx</span>
<span class="nf">sub</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">ecx</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="circumvention">Circumvention</h4>
<p>In order to mitigate these transformations we can do a variety of techniques based on Data Flow Analysis. Before we introduce these techniques, is important to understand that in order to succesfully implement Data Flow Analysis strategies we have to rely on a Intermediate Representation of the subject code. Compilers also rely on IRs to apply their program synthesis and code optimitations capabilities. In other words, We can deobfuscate these transformations by using the same techniques used by compilers for
their own optimization purposes.</p>

<p>These techniques are the following:</p>

<p><br /></p>

<h4 id="reachable-definition-analysis">Reachable Definition Analysis</h4>
<ul>
  <li>Forward dataflow analysis</li>
  <li>Analyze where the value of each variable was defined when a certain point in the program was reached</li>
  <li>Application:
    <ul>
      <li>Constant propagation/folding</li>
      <li>Transform expressions</li>
    </ul>
  </li>
</ul>

<p>An overview of how Reachability Analysis work can be shown in the following picture from Yuma’s Course:</p>

<div align="center">
<img src="/images/Reachability_Analysis.png" style="width: 100%; height: auto;" />
</div>

<p>The theoritical model to apply Reachability Analysis is the following</p>

<div align="center">
<img src="/images/RA_equ.png" style="width: 100%; height: auto;" />
</div>

<h4 id="liveless-analysis">Liveless Analysis</h4>

<ul>
  <li>Backward dataflow analysis</li>
  <li>Analyze whether the value x in the program point p may be used when following the edge starting from p in the flow graph with respect to x</li>
  <li>Application:
    <ul>
      <li>Dead code elimination</li>
    </ul>
  </li>
</ul>

<p>An overview of how Liveless Analysis work can be shown in the following picture from Yuma’s Course:
<br /></p>

<div align="center">
<img src="/images/Liveless_Analysis.png" style="width: 100%; height: auto;" />
</div>

<p>The theoritical model to apply Liveless Analysis is the following</p>
<div align="center">
<img src="/images/LA_equ.png" style="width: 100%; height: auto;" />
</div>

<p>Both reachable definition analysis and liveness analysis are IR optimization techniques used by a compiler backend, and are also useful for binary analysis.</p>

<p><br /></p>

<h4 id="practical-example-deobfuscating-ollvms-instruction-substitution-pass">Practical Example. Deobfuscating OLLVM’s Instruction Substitution Pass</h4>

<p>For this example we will be using the given example compiled with o-llvm -sub flag to enable OLLVM’s Intruction Substitution Pass.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">target_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">r</span><span class="p">;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">56</span><span class="p">;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">127</span><span class="p">;</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">target_function</span><span class="p">(</span><span class="n">argc</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"n=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Both target_functions before and after obfuscation look like this:</p>

<div align="center">
<img src="/images/inst_sub_r2.png" style="width: 100%; height: auto;" />
</div>

<p>Since we need a framework to lift the code to an IR to apply these types of optimization analyses, we can use MIASM’s Data Flow Analysis modules to deobfuscate transformations such as instruction substitution, dead/junk code or constant unfolding.</p>

<p>MIASM has a simple way of retrieving and lifting the subject function to MIASM IR:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="c1"># Opening Target File and Storing it in a 'Container' Object
</span><span class="n">cont</span> <span class="o">=</span> <span class="n">Container</span><span class="p">.</span><span class="n">from_stream</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">target</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">))</span>

<span class="c1"># Instantiating disassembler
</span><span class="n">machine</span> <span class="o">=</span> <span class="n">Machine</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">architecture</span> <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">architecture</span> <span class="k">else</span> <span class="n">cont</span><span class="p">.</span><span class="n">arch</span><span class="p">)</span>
<span class="n">dis</span> <span class="o">=</span> <span class="n">machine</span><span class="p">.</span><span class="n">dis_engine</span><span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">bin_stream</span><span class="p">,</span> <span class="n">loc_db</span><span class="o">=</span><span class="n">cont</span><span class="p">.</span><span class="n">loc_db</span><span class="p">)</span>

<span class="c1"># Disassembling and Extracting CFG
</span><span class="n">asmcfg</span> <span class="o">=</span> <span class="n">dis</span><span class="p">.</span><span class="n">dis_multiblock</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># Extracting IR archive and IRCFG
</span><span class="n">ir_arch</span> <span class="o">=</span> <span class="n">machine</span><span class="p">.</span><span class="n">ira</span><span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">loc_db</span><span class="p">)</span>
<span class="n">ircfg</span> <span class="o">=</span> <span class="n">ir_arch</span><span class="p">.</span><span class="n">new_ircfg_from_asmcfg</span><span class="p">(</span><span class="n">asmcfg</span><span class="p">)</span>

<span class="c1"># Simplifying IR
</span><span class="n">deadrm</span> <span class="o">=</span> <span class="n">DeadRemoval</span><span class="p">(</span><span class="n">ir_arch</span><span class="p">)</span>
<span class="n">entry_points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">dis</span><span class="p">.</span><span class="n">loc_db</span><span class="p">.</span><span class="n">get_offset_location</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">addr</span><span class="p">)])</span>
<span class="n">init_infos</span> <span class="o">=</span> <span class="n">ir_arch</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">.</span><span class="n">regs_init</span>
<span class="n">cst_propag_link</span> <span class="o">=</span> <span class="n">propagate_cst_expr</span><span class="p">(</span><span class="n">ir_arch</span><span class="p">,</span> <span class="n">ircfg</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">init_infos</span><span class="p">)</span>

<span class="c1"># deadrm(ircfg)
# remove_empty_assignblks(ircfg)
# This line simplifies the IR with the same features as above and more
</span><span class="n">ircfg</span><span class="p">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">expr_simp_high_to_explicit</span><span class="p">)</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>At this point we will be able to optimise the given subject function and consequently mitigate the aforementioned obfuscation techniques. In order to show the result in a more readable format, it would be nice to transform the optimized IR function representation back to x86, the original architecture we compiled our test case.
Unfortunatelly, MIASM’s IR is not backwards compatible with x86, however MIASM provide capabilities to translate MIASM’s IR to LLVM IR to then retrieve back the optimized subject function in its native representation.</p>

<p>In order to do this we can do the following:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre><span class="c1"># Instantiate an LLVM context and Function to fill
</span><span class="n">context</span> <span class="o">=</span> <span class="n">LLVMContext_IRCompilation</span><span class="p">()</span>
<span class="n">context</span><span class="p">.</span><span class="n">ir_arch</span> <span class="o">=</span> <span class="n">ir_arch</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">LLVMFunction_IRCompilation</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">"test"</span><span class="p">)</span>
<span class="n">func</span><span class="p">.</span><span class="n">ret_type</span> <span class="o">=</span> <span class="n">llvm_ir</span><span class="p">.</span><span class="n">VoidType</span><span class="p">()</span>
<span class="n">func</span><span class="p">.</span><span class="n">init_fc</span><span class="p">()</span>

<span class="p">...</span>

<span class="c1"># IRCFG is imported, without the final "ret void"
</span><span class="n">func</span><span class="p">.</span><span class="n">from_ircfg</span><span class="p">(</span><span class="n">ircfg</span><span class="p">,</span> <span class="n">append_ret</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c1"># Finish the function
</span><span class="n">func</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">ret_void</span><span class="p">()</span>

<span class="c1"># Parsing LLVM IR
</span><span class="n">M</span> <span class="o">=</span> <span class="n">llvm</span><span class="p">.</span><span class="n">parse_assembly</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
<span class="n">M</span><span class="p">.</span><span class="n">verify</span><span class="p">()</span>

<span class="c1"># Initialising Native Exporter
</span><span class="n">llvm</span><span class="p">.</span><span class="n">initialize</span><span class="p">()</span>
<span class="n">llvm</span><span class="p">.</span><span class="n">initialize_native_target</span><span class="p">()</span>
<span class="n">llvm</span><span class="p">.</span><span class="n">initialize_native_asmprinter</span><span class="p">()</span>

<span class="c1"># Optimisation to clean value computation
</span><span class="n">pmb</span> <span class="o">=</span> <span class="n">llvm</span><span class="p">.</span><span class="n">create_pass_manager_builder</span><span class="p">()</span>
<span class="n">pmb</span><span class="p">.</span><span class="n">opt_level</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">pm</span> <span class="o">=</span> <span class="n">llvm</span><span class="p">.</span><span class="n">create_module_pass_manager</span><span class="p">()</span>
<span class="n">pmb</span><span class="p">.</span><span class="n">populate</span><span class="p">(</span><span class="n">pm</span><span class="p">)</span>
<span class="n">pm</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

<span class="c1"># Generate Binary output
</span><span class="n">target</span> <span class="o">=</span> <span class="n">llvm</span><span class="p">.</span><span class="n">Target</span><span class="p">.</span><span class="n">from_default_triple</span><span class="p">()</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="n">from_triple</span><span class="p">(</span><span class="s">'i386-pc-linux-gnu'</span><span class="p">)</span>
<span class="n">target_machine</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="n">create_target_machine</span><span class="p">()</span>
<span class="n">obj_bin</span> <span class="o">=</span> <span class="n">target_machine</span><span class="p">.</span><span class="n">emit_object</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="n">obj</span> <span class="o">=</span> <span class="n">llvm</span><span class="p">.</span><span class="n">ObjectFileRef</span><span class="p">.</span><span class="n">from_data</span><span class="p">(</span><span class="n">obj_bin</span><span class="p">)</span>
<span class="nb">open</span><span class="p">(</span><span class="s">"./%s-%s.o"</span> <span class="o">%</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">target</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">))),</span> <span class="s">"wb"</span><span class="p">).</span><span class="n">write</span><span class="p">(</span><span class="n">obj_bin</span><span class="p">)</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>The full script can be downloaded <a href="https://github.com/ulexec/ulexec.github.io/raw/master/files/optimize.py">here</a></p>

<p>After running the previous script, we will see it will generate an ET_REL type ELF file containing the native version of our deobfuscated function by optimization.
The following is the result of this:</p>

<div align="center">
<img src="/images/deobfuscated_func.png" style="width: 100%; height: auto;" />
</div>

<p>As we can see in the previous screenshot, there is some dead code resident in the optimized function. This dead code represents the local variables used in the obfuscated (and original) version of the function.</p>

<p>Data Flow Analysis and optimizations are restricted to memory writes along with other constraints such as variables involved in conditional jumps.
Despite this, we can clearly see that Data Flow Analysis can be very effective for instruction subtitution deobfuscation giving us a simplified version of what the function may have looked like after and even before obfuscation.</p>

<p>As we mentioned there are some additional contraints while removing some of the dead code after simplification, such as memory writes or variables needed for conditional branches. In regards to conditional branches, in the next section we will cover the concept of opaque predicates and what we can do to indentify and mitigate them.</p>

<p><br /></p>

<h3 id="opaque-predicates">Opaque Predicates</h3>

<p>Opaque predicates in a nutshell is a commonly used technique in code obfuscation intended to add complexity to control flow usually implemented as conditional branches although these conditional branches have a deterministic control flow.</p>

<p>A simple example of what opaque predicates are can be shown in the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>        <span class="c1">// opaque predicate</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">"This is never going to execute"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"predifined control flow"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>The previous C snippet is an over-simplified opaque predicate example, however its important to illustrate the concept we are trying to tackle. As we can see in the  example, a and b local variables are never going to satisfy the equality condition of the if statement since the values of a and b are not dependant on function’s input, therefore the condition itself is not prone to change.</p>

<p>This same concept can be extrapolated to more complex equalities/conditions usually appearing in high volume on a subject obfuscated application.
Depending on the implementation sophistication of this technique, control flow clarity can be highly affected and therefore the interpretation and time of analysis of a subject application.</p>

<p><br /></p>

<h4 id="circumvention-1">Circumvention</h4>
<p>One approach to identify opaque predicates is to use Symbolic Execution along with an SMT solver in order to check feasibility on conditional branches.</p>

<p>How it works:</p>
<ul>
  <li>Execute a program sequentially while treating input values as symbols that represent all possible values.</li>
  <li>Add constraints on symbols.
    <ul>
      <li>Path Constraint: Constraints to execute a path.</li>
      <li>Symbolic Store: Updated symbol information.</li>
    </ul>
  </li>
  <li>When the target address of the conditional jump is reached, solve the constraints with a SMT solver and get a concrete input value.
    <ul>
      <li>Need to convert IR to SMT solver-acceptable expressions.</li>
    </ul>
  </li>
</ul>

<p>Opaque predicates have a deterministic feasibility regardless of input values.
Therefore, we can invoke a SMT solver at every conditional branch and verify whether there is an input value that evaluates the condition to a True or False result.
If a subject conditional branch is not dependant on a input value the branch should be an opaque predicate.
We can apply the technique discussed above and attempt to detect opaque predicates via Symbolic Execution + SMT solver.</p>

<p><br /></p>

<h4 id="practical-example-deobfuscating-x-tunnel-opaque-predicates">Practical Example. Deobfuscating X-Tunnel Opaque Predicates</h4>
<p>The binary file we are going to use for this example is the following:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">X</span><span class="o">-</span><span class="n">Tunnel</span><span class="o">:</span> <span class="n">a979c5094f75548043a22b174aa10e1f2025371bd9e1249679f052b168e194b3</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The first thing we have to do is to write a path exploration function based on Symbolic Execution.
We can do this with MIASM as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">ir</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">start_symbols</span><span class="p">,</span>
        <span class="n">ircfg</span><span class="p">,</span> <span class="n">cond_limit</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">uncond_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">lbl_stop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">final_states</span><span class="o">=</span><span class="p">[]):</span>

    <span class="k">def</span> <span class="nf">codepath_walk</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">conds</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">final_states</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>

        <span class="p">...</span>

        <span class="c1"># Instantiate MIASM Symbolic Execution Engine
</span>        <span class="n">sb</span> <span class="o">=</span> <span class="n">SymbolicExecutionEngine</span><span class="p">(</span><span class="n">ir</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uncond_limit</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">ExprInt</span><span class="p">):</span>
                <span class="c1"># recursion delimiter
</span>                <span class="k">if</span> <span class="n">addr</span><span class="p">.</span><span class="n">_get_int</span><span class="p">()</span> <span class="o">==</span> <span class="n">lbl_stop</span><span class="p">:</span>
                    <span class="n">final_states</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">FinalState</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">conds</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
                    <span class="k">return</span>

            <span class="c1"># Append all executed Paths
</span>            <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

            <span class="c1"># Run Symbolic Engine at block
</span>            <span class="n">pc</span> <span class="o">=</span> <span class="n">sb</span><span class="p">.</span><span class="n">run_block_at</span><span class="p">(</span><span class="n">ircfg</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>

            <span class="c1"># if IR expression is a condition
</span>            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="n">ExprCond</span><span class="p">):</span>

                <span class="c1"># Create conditions that satisfy true or false paths
</span>                <span class="n">cond_true</span>  <span class="o">=</span> <span class="p">{</span><span class="n">pc</span><span class="p">.</span><span class="n">cond</span><span class="p">:</span> <span class="n">ExprInt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">)}</span>
                <span class="n">cond_false</span> <span class="o">=</span> <span class="p">{</span><span class="n">pc</span><span class="p">.</span><span class="n">cond</span><span class="p">:</span> <span class="n">ExprInt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)}</span>

                <span class="c1"># Compute the destination addr of the true or false paths
</span>                <span class="n">addr_true</span>  <span class="o">=</span> <span class="n">expr_simp</span><span class="p">(</span>
                    <span class="n">sb</span><span class="p">.</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">pc</span><span class="p">.</span><span class="n">replace_expr</span><span class="p">(</span><span class="n">cond_true</span><span class="p">),</span> <span class="p">{}))</span>

                <span class="n">addr_false</span> <span class="o">=</span> <span class="n">expr_simp</span><span class="p">(</span>
                    <span class="n">sb</span><span class="p">.</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">pc</span><span class="p">.</span><span class="n">replace_expr</span><span class="p">(</span><span class="n">cond_false</span><span class="p">),</span> <span class="p">{}))</span>

                <span class="c1"># Adding previous conditions of previous
</span>                <span class="c1"># blocks in path to satisfy reachability of current block
</span>                <span class="n">conds_true</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">conds</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">cond_true</span><span class="p">.</span><span class="n">items</span><span class="p">())</span>
                <span class="n">conds_false</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">conds</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">cond_false</span><span class="p">.</span><span class="n">items</span><span class="p">())</span>

                <span class="c1"># Check feasibility of True condition on conditional branch
</span>                <span class="k">if</span> <span class="n">check_path_feasibility</span><span class="p">(</span><span class="n">conds_true</span><span class="p">):</span>
                    <span class="c1"># If True path is feasible, continue with Symbolic Execution
</span>                    <span class="n">codepath_walk</span><span class="p">(</span>
                        <span class="n">addr_true</span><span class="p">,</span> <span class="n">sb</span><span class="p">.</span><span class="n">symbols</span><span class="p">.</span><span class="n">copy</span><span class="p">(),</span>
                        <span class="n">conds_true</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">final_states</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If not, store the current block and stop recursion
</span>                    <span class="n">final_states</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">FinalState</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">conds_true</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">check_path_feasibility</span><span class="p">(</span><span class="n">conds_false</span><span class="p">):</span>
                    <span class="c1"># If False path is feasible, continue with Symbolic Execution
</span>                    <span class="n">codepath_walk</span><span class="p">(</span>
                        <span class="n">addr_false</span><span class="p">,</span> <span class="n">sb</span><span class="p">.</span><span class="n">symbols</span><span class="p">.</span><span class="n">copy</span><span class="p">(),</span>
                        <span class="n">conds_false</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">final_states</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If not, store the current block and stop recursion
</span>                    <span class="n">final_states</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">FinalState</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">conds_false</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>

                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If current IR expression is not a Condition,
</span>                <span class="c1"># simplify block expresion
</span>                <span class="n">addr</span> <span class="o">=</span> <span class="n">expr_simp</span><span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">pc</span><span class="p">))</span>

        <span class="c1"># Append Final state
</span>        <span class="n">final_states</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">FinalState</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">conds</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
        <span class="k">return</span>

    <span class="c1"># Start by walking function from its start address
</span>    <span class="k">return</span> <span class="n">codepath_walk</span><span class="p">(</span><span class="n">start_addr</span><span class="p">,</span> <span class="n">start_symbols</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">final_states</span><span class="p">,</span> <span class="p">[])</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As seen in the previous snippet, the overall steps of our path exploration algorithm are the following:</p>
<ul>
  <li>Symbolically Execute every block in current function until it finds a conditional IR expression (which would be the same as a conditional instruction in its native representation).</li>
  <li>Once this conditional expression is reached, we then evaluate both the branch destination address if the condition would be satisfied and if it wouldn’t accordingly.</li>
  <li>When we have identified the two different branch addresses, then we compute the feasibility of each subject branch (which includes all previous conditions to reach to the designated destination address) and if its feasible we continue symbolically executing the branch. If not we mark that current path as finished and we store it.</li>
</ul>

<p>The feasibility of the branch condition can be done via MIASM’s z3 SMT Solver Translator:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">check_path_feasibility</span><span class="p">(</span><span class="n">conds</span><span class="p">):</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">z3</span><span class="p">.</span><span class="n">Solver</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">lval</span><span class="p">,</span> <span class="n">rval</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">:</span>
        <span class="n">z3_cond</span> <span class="o">=</span> <span class="n">Translator</span><span class="p">.</span><span class="n">to_language</span><span class="p">(</span><span class="s">"z3"</span><span class="p">).</span><span class="n">from_expr</span><span class="p">(</span><span class="n">lval</span><span class="p">)</span>
        <span class="n">solver</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">z3_cond</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">rval</span><span class="p">.</span><span class="n">arg</span><span class="p">))</span>

    <span class="n">rslt</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">check</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">rslt</span> <span class="o">==</span> <span class="n">z3</span><span class="p">.</span><span class="n">sat</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>After Symbolic Execution of our target function is done, we will have an array of all of the stored final states of each path in the function.
These final states will contained every executed block.
In order to identify blocks which have not been executed, we do the following:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>
<span class="p">...</span>

<span class="c1"># The IR nodes in final_states array are the path nodes that were executed.
# We collect the 'lock_key' or block labels of each of the nodes executed
</span><span class="k">for</span> <span class="n">final_state</span> <span class="ow">in</span> <span class="n">final_states</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">final_state</span><span class="p">.</span><span class="n">result</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">final_state</span><span class="p">.</span><span class="n">path_history</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">lbl</span> <span class="o">=</span> <span class="n">ircfg</span><span class="p">.</span><span class="n">get_loc_key</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ExprInt</span><span class="p">):</span>
                <span class="n">lbl</span> <span class="o">=</span> <span class="n">ircfg</span><span class="p">.</span><span class="n">get_loc_key</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">_get_int</span><span class="p">())</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">LocKey</span><span class="p">):</span>
                <span class="n">lbl</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">loc_key</span>
            <span class="k">if</span> <span class="n">lbl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">executed_lockey</span><span class="p">:</span>
                <span class="n">executed_lockey</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>

<span class="c1"># We then collect the non-executed blocks by comparing the executed ones
# with the totality of the blocks in the IRCFG
</span><span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">irblock</span> <span class="ow">in</span> <span class="n">viewitems</span><span class="p">(</span><span class="n">ircfg</span><span class="p">.</span><span class="n">blocks</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">lbl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">executed_lockey</span><span class="p">:</span>
        <span class="n">unexecuted_lockey</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>

<span class="p">...</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Once we have the locations of the blocks that haven’t been executed, we can do a variety of things.
We could simply mark the non-executed blocks in order to inspect the target function for further analysis.
Yuma Kurogome shows how to do this in his course by dynamically creating an IDC script based on the context retrieved in previous stages:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">to_idc</span><span class="p">(</span><span class="n">lockeys</span><span class="p">,</span> <span class="n">asmcfg</span><span class="p">):</span>

    <span class="n">header</span> <span class="o">=</span> <span class="s">'''
#include &lt;idc.idc&gt;
static main(){
'''</span>
    <span class="n">footer</span> <span class="o">=</span> <span class="s">'''
}
'''</span>
    <span class="n">body</span> <span class="o">=</span> <span class="s">''</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'op-color.idc'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">lockeys</span><span class="p">:</span>
        <span class="n">asmblk</span> <span class="o">=</span> <span class="n">asmcfg</span><span class="p">.</span><span class="n">loc_key_to_block</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">asmblk</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">asmblk</span><span class="p">.</span><span class="n">lines</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">offset</span><span class="p">))</span>
                <span class="n">body</span> <span class="o">+=</span> <span class="s">'SetColor(0x%08x, CIC_ITEM, 0xc7c7ff);</span><span class="se">\n</span><span class="s">'</span><span class="o">%</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span>

    <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="o">+</span><span class="n">body</span><span class="o">+</span><span class="n">footer</span><span class="p">)</span>
    <span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>After applying this we can obtain the following results (function at 0x40A6A0):</p>

<div align="center">
<img src="/images/x-tunnel_ops_detect.png" style="width: 100%; height: auto;" />
</div>

<p>This can help us to figure out the logic of the implementation of the subject opaque predicates. Once this is clear, we can then write a solution to patch the binary to obtain a more clear view of the function’s control flow to apply further analysis to it such as optimizations or data flow analysis after opaque predicates are removed.
I decided to write a solution to remove X-Tunnel’s opaque predicates by using radare2 via its r2pipe Python binding:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">remove_xtunnel_op</span><span class="p">(</span><span class="n">lockeys</span><span class="p">,</span> <span class="n">asmcfg</span><span class="p">):</span>
    <span class="c1"># Opening File in r2
</span>    <span class="n">r2</span> <span class="o">=</span> <span class="n">r2pipe</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">"./x-tunnel.bin"</span><span class="p">,</span> <span class="p">[</span><span class="s">"-w"</span><span class="p">])</span>

    <span class="c1"># applying reference analysis
</span>    <span class="n">r2</span><span class="p">.</span><span class="n">cmd</span><span class="p">(</span><span class="s">"aar"</span><span class="p">)</span>

    <span class="c1"># iterating for each block label
</span>    <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">lockeys</span><span class="p">:</span>
        <span class="c1"># retrieving block from label
</span>        <span class="n">asmblk</span> <span class="o">=</span> <span class="n">asmcfg</span><span class="p">.</span><span class="n">loc_key_to_block</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">asmblk</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">asmblk</span><span class="p">.</span><span class="n">lines</span><span class="p">:</span>
                <span class="c1"># seeking to address of instruction
</span>                <span class="n">r2</span><span class="p">.</span><span class="n">cmd</span><span class="p">(</span><span class="s">"s %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">offset</span><span class="p">))</span>

                <span class="c1"># checking if there is any xrefs to
</span>                <span class="c1"># current instruction
</span>                <span class="n">xref</span> <span class="o">=</span> <span class="n">r2</span><span class="p">.</span><span class="n">cmdj</span><span class="p">(</span><span class="s">"axtj"</span><span class="p">)</span>
                <span class="k">if</span>  <span class="n">xref</span><span class="p">:</span>
                    <span class="c1"># retrieving the reference source address
</span>                    <span class="n">xref_from</span> <span class="o">=</span> <span class="n">xref</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">'from'</span><span class="p">]</span>

                    <span class="c1"># retrieving the opcode
</span>                    <span class="n">opcode</span> <span class="o">=</span> <span class="n">xref</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">'opcode'</span><span class="p">]</span>

                    <span class="c1"># seeking to reference source address
</span>                    <span class="n">r2</span><span class="p">.</span><span class="n">cmd</span><span class="p">(</span><span class="s">"s %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">xref_from</span><span class="p">))</span>

                    <span class="c1"># changing opcode for nop if its a je or a non
</span>                    <span class="c1"># conditional jump if its any other branch instruction
</span>                    <span class="n">r2</span><span class="p">.</span><span class="n">cmd</span><span class="p">(</span><span class="s">"wao %s"</span> <span class="o">%</span> <span class="p">(</span><span class="s">"nop"</span> <span class="k">if</span> <span class="s">'je'</span> <span class="ow">in</span> <span class="n">opcode</span> <span class="k">else</span> <span class="s">"nocj"</span><span class="p">))</span>

                <span class="c1"># seek back to original block instrution
</span>                <span class="n">r2</span><span class="p">.</span><span class="n">cmd</span><span class="p">(</span><span class="s">"s %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">offset</span><span class="p">))</span>

                <span class="c1"># patching instruction with a nop
</span>                <span class="n">r2</span><span class="p">.</span><span class="n">cmd</span><span class="p">(</span><span class="s">"wao nop"</span><span class="p">)</span>

                <span class="c1"># seeking to previous instruction
</span>                <span class="n">r2</span><span class="p">.</span><span class="n">cmd</span><span class="p">(</span><span class="s">"so -1"</span><span class="p">)</span>

                <span class="c1"># retrieving its opcode
</span>                <span class="n">opcode</span> <span class="o">=</span> <span class="n">r2</span><span class="p">.</span><span class="n">cmdj</span><span class="p">(</span><span class="s">"pdj 1"</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="s">'opcode'</span><span class="p">]</span>

                <span class="c1"># if its a jne, change it to its
</span>                <span class="c1"># non-conditional form
</span>                <span class="k">if</span> <span class="s">'jne'</span> <span class="ow">in</span> <span class="n">opcode</span><span class="p">:</span>
                    <span class="n">r2</span><span class="p">.</span><span class="n">cmd</span><span class="p">(</span><span class="s">"wao nocj"</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The full script can be downloaded <a href="https://github.com/ulexec/ulexec.github.io/raw/master/files/remove_xtunnel_ops.py">here</a></p>

<p>After applying this script we can obtain results as follows (function at 0x40A6A0):</p>

<div align="center">
<img src="/images/x-tunnel_ops.png" style="width: 100%; height: auto;" />
</div>

<p>This approach can work for deterministic opaque perdicates although it has the following limitations:</p>
<ul>
  <li>Path exploration algorithm can be very slow.</li>
  <li>SMT solver may have difficulties to solve specific contraints such as cryptographic schemes or hashing algorithms.</li>
  <li>Possibility of Path Explosion if input-dependant loops or recursion are found among other <a href="https://arxiv.org/pdf/1908.01549.pdf">techniques</a>.</li>
</ul>

<p>There are known attacks against Symbolic Execution Analysis:</p>
<ul>
  <li>Input Dependant loops.</li>
  <li>Range Dividers.</li>
</ul>

<p>Another approach to detect opaque predicates: Abstract Interpretation (TODO. Some nice <a href="https://www.msreverseengineering.com/blog/2018/2/26/concrete-and-abstract-interpretation-explained-through-chess">reference</a> by Rolf Rolles)</p>

<p>In the following section we will cover an approach to detect Range Dividers and how we can circumvent them.</p>

<p><br /></p>

<h3 id="range-dividers">Range Dividers</h3>

<p><a href="https://www.researchgate.net/publication/311491954_Code_obfuscation_against_symbolic_execution_attacks">Range dividers</a> are branch conditions that can be inserted at an arbitrary position inside a basic block, such that they divide the input range into multiple sets.</p>

<p>A simple example to illustrate this technique can be shown below:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span> <span class="n">str</span><span class="o">++</span> <span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">chr</span> <span class="o">=</span> <span class="o">*</span><span class="n">str</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">;</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">chr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">^</span> <span class="n">chr</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash</span> <span class="o">*</span> <span class="mi">128</span><span class="p">)</span> <span class="o">^</span> <span class="n">chr</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>     <span class="c1">// obfuscated version of case 1</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="p">...</span>

            <span class="nl">default:</span>    <span class="c1">// obfuscated version of case 1</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="p">...</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In contrast to opaque predicates, range divider predicates may have multiple branches, any of which could be true and false depending on program input. This will cause symbolic execution engines to explore all branches of a range divider.</p>
<ul>
  <li>Branch execution is dependant on an input value</li>
  <li>All predicate branches have the same semantic meaning</li>
  <li>Robust against Symbolic Execution/Abstract Interpretation</li>
  <li>Almost like a n-way Opaque Predicate</li>
</ul>

<p>The eﬀectiveness of a range divider predicate against symbolic execution depends on:</p>
<ul>
  <li>Number of branches of the predicate</li>
  <li>The number of times the predicate is executed</li>
</ul>

<h4 id="circumvention-2">Circumvention</h4>

<p>An approach to identify Range Dividers is by Semtantic Equivalence Checking.
Semantic Equivalence is an apporach to identify if two given sets of instructions have the same behavior based on the following premise:</p>
<ul>
  <li>Same Code: Syntactically Equivalent</li>
  <li>Same Behavior: Semantically Equivalent</li>
</ul>

<p>How it works:</p>
<ul>
  <li>Perform Symbolic Execution per basic block on a given function.</li>
  <li>Check for basic blocks semantic and syntactic equivalence within a given function.</li>
  <li>Can be also seen as Semantic basic block diffing</li>
</ul>

<h4 id="practical-example-deobfuscating-asprox-range-dividers">Practical Example. Deobfuscating Asprox Range Dividers</h4>
<p>The binary file we are going to use for this example is the following:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nl">Asprox:</span> <span class="n">c56792bea8ac5fbf893ae3df1be0c3c878a615db6b24fd5253e5cbbc2e3e1dd3</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The first thing we have to do is to retrieve all blocks from the subject obfuscated function.
Then we should compare for syntactic and semantic equivalence every block in the funtion with one another.
We can do this as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="rouge-code"><pre>    <span class="p">...</span>

    <span class="c1"># enumerate all blogs in target function
</span>    <span class="n">target_blocks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cn</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">asmcfg</span><span class="p">.</span><span class="n">blocks</span><span class="p">):</span>
        <span class="n">target_blocks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># iterate over all blocks to select src block
</span>    <span class="k">for</span> <span class="n">src_blk</span> <span class="ow">in</span> <span class="n">target_blocks</span><span class="p">:</span>
        <span class="c1"># retrieve src block label from src block
</span>        <span class="n">src_ldl</span> <span class="o">=</span> <span class="n">src_blk</span><span class="p">.</span><span class="n">_loc_key</span>

        <span class="c1"># Skip a basic blocks containing only single instruction
</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">src_blk</span><span class="p">.</span><span class="n">lines</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">src_blk</span><span class="p">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dstflow</span><span class="p">():</span>
            <span class="k">continue</span>

        <span class="c1"># iterate through all blocks again
</span>        <span class="c1"># to select dst block
</span>        <span class="k">for</span> <span class="n">dst_blk</span> <span class="ow">in</span> <span class="n">target_blocks</span><span class="p">:</span>
            <span class="c1"># retrieve dst block label from dst block
</span>            <span class="n">dst_ldl</span> <span class="o">=</span> <span class="n">dst_blk</span><span class="p">.</span><span class="n">_loc_key</span>

            <span class="c1"># Skip a basic block containing only single instruction
</span>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dst_blk</span><span class="p">.</span><span class="n">lines</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">==</span>  <span class="ow">and</span> <span class="n">dst_blk</span><span class="p">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dstflow</span><span class="p">():</span>
                <span class="k">continue</span>

            <span class="c1"># Skip if src and dst block are the same block
</span>            <span class="k">if</span> <span class="n">src_ldl</span> <span class="o">==</span> <span class="n">dst_ldl</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Skip if src and dst blocks have already been matched
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">src_ldl</span><span class="p">,</span> <span class="n">dst_ldl</span><span class="p">)</span> <span class="ow">in</span> <span class="n">results</span><span class="p">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">or</span> \
                    <span class="p">(</span><span class="n">dst_ldl</span><span class="p">,</span> <span class="n">src_ldl</span><span class="p">)</span> <span class="ow">in</span> <span class="n">results</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">continue</span>

            <span class="c1"># Check for syntax equivalence
</span>            <span class="n">r_syntax</span> <span class="o">=</span> <span class="n">syntax_compare</span><span class="p">(</span><span class="n">src_blk</span><span class="p">,</span> <span class="n">dst_blk</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">r_syntax</span><span class="p">:</span>
                <span class="c1"># If the syntax of two blocks is same, then the semantics of them is also same.
</span>                <span class="n">r_semantic</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check for semantic equivalence
</span>                <span class="n">r_semantic</span> <span class="o">=</span> <span class="n">semantic_compare</span><span class="p">(</span><span class="n">src_blk</span><span class="p">,</span> <span class="n">dst_blk</span><span class="p">,</span> <span class="n">ir_arch0</span><span class="p">,</span> <span class="n">ir_arch1</span><span class="p">,</span> <span class="n">asmcfg</span><span class="p">)</span>

            <span class="c1"># save results of syntax and semantic checks
</span>            <span class="n">results</span><span class="p">[(</span><span class="n">src_ldl</span><span class="p">,</span> <span class="n">dst_ldl</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r_syntax</span><span class="p">,</span> <span class="n">r_semantic</span><span class="p">)]</span>

            <span class="p">...</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>Syntactic equivalence is fairly straight forward, for this we don’t even need to lift the subject block into IR.
This is how it can be implemented:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">syntax_compare</span><span class="p">(</span><span class="n">blk0</span><span class="p">,</span> <span class="n">blk1</span><span class="p">):</span>
    <span class="c1"># if blocks do not contain the same
</span>    <span class="c1"># number of instructions return
</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blk0</span><span class="p">.</span><span class="n">lines</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blk1</span><span class="p">.</span><span class="n">lines</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="c1"># iterate through all instructions in blocks
</span>    <span class="k">for</span> <span class="n">l0</span><span class="p">,</span> <span class="n">l1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">blk0</span><span class="p">.</span><span class="n">lines</span><span class="p">,</span> <span class="n">blk1</span><span class="p">.</span><span class="n">lines</span><span class="p">):</span>

        <span class="c1"># if intruction is a branch
</span>        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">l0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">'J'</span><span class="p">:</span>
            <span class="c1"># retrieve instruction opcode
</span>            <span class="n">instr0</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">l0</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">instr1</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">l1</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">instr0</span> <span class="o">!=</span> <span class="n">instr1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

        <span class="c1"># any other instruction
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">l0</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">(</span><span class="n">l1</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="bp">True</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>On the other hand, for Semantic equivalence its slightly more complicated:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">semantic_compare</span><span class="p">(</span><span class="n">blk0</span><span class="p">,</span> <span class="n">blk1</span><span class="p">,</span> <span class="n">ir_arch0</span><span class="p">,</span> <span class="n">ir_arch1</span><span class="p">,</span> <span class="n">asmcfg</span><span class="p">,</span> <span class="n">flag_cmp</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="c1"># create empty IR CFG for src block
</span>    <span class="n">src_ircfg</span> <span class="o">=</span> <span class="n">IRCFG</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">ir_arch0</span><span class="p">.</span><span class="n">loc_db</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># add src block to empty IR CFG
</span>        <span class="n">ir_arch0</span><span class="p">.</span><span class="n">add_asmblock_to_ircfg</span><span class="p">(</span><span class="n">blk0</span><span class="p">,</span> <span class="n">src_ircfg</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">NotImplementedError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="c1"># create empty IR CFG for dst block
</span>    <span class="n">dst_ircfg</span> <span class="o">=</span> <span class="n">IRCFG</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">ir_arch1</span><span class="p">.</span><span class="n">loc_db</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># add dst block to empty IR CFG
</span>        <span class="n">ir_arch1</span><span class="p">.</span><span class="n">add_asmblock_to_ircfg</span><span class="p">(</span><span class="n">blk1</span><span class="p">,</span> <span class="n">dst_ircfg</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">NotImplementedError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="c1"># Check if blocks were added to their IRCFG correctly
</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">src_ircfg</span><span class="p">.</span><span class="n">blocks</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dst_ircfg</span><span class="p">.</span><span class="n">blocks</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">for</span> <span class="n">src_lbl</span><span class="p">,</span> <span class="n">dst_lbl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">src_ircfg</span><span class="p">.</span><span class="n">blocks</span><span class="p">,</span> <span class="n">dst_ircfg</span><span class="p">.</span><span class="n">blocks</span><span class="p">):</span>
        <span class="c1"># retrieve both src and dst blocks from their labels
</span>        <span class="n">src_irb</span> <span class="o">=</span> <span class="n">src_ircfg</span><span class="p">.</span><span class="n">blocks</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">src_lbl</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">dst_irb</span> <span class="o">=</span> <span class="n">dst_ircfg</span><span class="p">.</span><span class="n">blocks</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">dst_lbl</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="c1"># symbolically execute them to evaluate
</span>        <span class="c1"># semantic equivalence
</span>        <span class="n">r</span> <span class="o">=</span> <span class="n">execute_symbolic_execution</span><span class="p">(</span>
                            <span class="n">src_irb</span><span class="p">,</span> <span class="n">dst_irb</span><span class="p">,</span>
                            <span class="n">ir_arch0</span><span class="p">,</span> <span class="n">ir_arch1</span><span class="p">,</span>
                            <span class="n">src_ircfg</span><span class="p">,</span> <span class="n">dst_ircfg</span><span class="p">,</span>
                            <span class="n">flag_cmp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We lift both of the ASMBlock into IR ones (IRBlock of AssignBlocks) and then we symbolically execute them.
In order to sucessfully symbolically execute both of them, some default setup for each IR block has to be done:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="rouge-code"><pre>    <span class="p">...</span>

    <span class="c1"># Initialize symbol context with register context
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_regs_ids</span><span class="p">):</span>
        <span class="n">src_symbols</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_regs_ids_init</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">dst_symbols</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_regs_ids_init</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Instantiate Symbolic Execution Engine for src block
</span>    <span class="n">src_sb</span> <span class="o">=</span> <span class="n">SymbolicExecutionEngine</span><span class="p">(</span><span class="n">ir_arch0</span><span class="p">,</span> <span class="n">src_symbols</span><span class="p">)</span>

    <span class="c1"># for each IR instruction in src block
</span>    <span class="k">for</span> <span class="n">assignblk</span> <span class="ow">in</span> <span class="n">src_irb</span><span class="p">:</span>
        <span class="n">skip_update</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c1"># retrieve IR expression and operand in block
</span>        <span class="k">for</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">viewitems</span><span class="p">(</span><span class="n">assignblk</span><span class="p">):</span>
            <span class="c1"># If operand involves EIP or ret
</span>            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="s">'EIP'</span><span class="p">,</span> <span class="s">'IRDst'</span><span class="p">]:</span>
                <span class="c1"># skip symbolic execution
</span>                <span class="n">skip_update</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c1"># otherwise symbolically execute IR expression
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_update</span><span class="p">:</span>
            <span class="n">src_sb</span><span class="p">.</span><span class="n">eval_updt_assignblk</span><span class="p">(</span><span class="n">assignblk</span><span class="p">)</span>

    <span class="c1"># Instantiate Symbolic Execution Engine for dest block
</span>    <span class="n">dst_sb</span> <span class="o">=</span> <span class="n">SymbolicExecutionEngine</span><span class="p">(</span><span class="n">ir_arch1</span><span class="p">,</span> <span class="n">dst_symbols</span><span class="p">)</span>

    <span class="c1"># retrieve IR expression and operand in block
</span>    <span class="k">for</span> <span class="n">assignblk</span> <span class="ow">in</span> <span class="n">dst_irb</span><span class="p">:</span>
        <span class="n">skip_update</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c1"># If operand involves EIP or ret
</span>        <span class="k">for</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">viewitems</span><span class="p">(</span><span class="n">assignblk</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="s">'EIP'</span><span class="p">,</span> <span class="s">'IRDst'</span><span class="p">]:</span>
                <span class="c1"># skip symbolic execution
</span>                <span class="n">skip_update</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_update</span><span class="p">:</span>
            <span class="c1"># otherwise symbolically execute IR expression
</span>            <span class="n">dst_sb</span><span class="p">.</span><span class="n">eval_updt_assignblk</span><span class="p">(</span><span class="n">assignblk</span><span class="p">)</span>

    <span class="c1"># set stack top for each symbolic engine
</span>    <span class="n">src_sb</span><span class="p">.</span><span class="n">del_mem_above_stack</span><span class="p">(</span><span class="n">ir_arch0</span><span class="p">.</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">dst_sb</span><span class="p">.</span><span class="n">del_mem_above_stack</span><span class="p">(</span><span class="n">ir_arch1</span><span class="p">.</span><span class="n">sp</span><span class="p">)</span>

    <span class="p">...</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As we can see we have to configure the symbols we desire to symbolize, create one symbolic instance per block, Symbolically execute block and set up the top of the stack of each symbolic engine.</p>

<p>When this is done then we can start checking for semantic equivalence by evaluating each of the symbol’s contraints of each symbolically executed block:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="rouge-code"><pre>    <span class="p">...</span>

     <span class="c1"># Retrieve all memory accesses from src and dst symbolic engines
</span>    <span class="n">all_memory_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dst_sb</span><span class="p">.</span><span class="n">symbols</span><span class="p">.</span><span class="n">memory</span><span class="p">()]</span> <span class="o">+</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">src_sb</span><span class="p">.</span><span class="n">symbols</span><span class="p">.</span><span class="n">memory</span><span class="p">()]</span>

    <span class="c1"># iterate through all register and memory symbols
</span>    <span class="c1"># from both symbolic engines
</span>    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_regs_ids</span> <span class="o">+</span> <span class="n">all_memory_ids</span><span class="p">:</span>
        <span class="c1"># keep iterating if symbol is EIP
</span>        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="s">'EIP'</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># keep iterating if symbol is eflags
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">flag_cmp</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">zf</span><span class="p">,</span> <span class="n">nf</span><span class="p">,</span> <span class="n">pf</span><span class="p">,</span> <span class="n">of</span><span class="p">,</span> <span class="n">cf</span><span class="p">,</span> <span class="n">af</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">tf</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="c1"># retrieve value of symbol from each symbolic engine
</span>        <span class="n">v0</span> <span class="o">=</span> <span class="n">src_sb</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">dst_sb</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># keep iterating if symbol value is the same
</span>        <span class="k">if</span> <span class="n">v0</span> <span class="o">==</span> <span class="n">v1</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># instantiate z3 SAT solver
</span>        <span class="n">solver</span> <span class="o">=</span> <span class="n">z3</span><span class="p">.</span><span class="n">Solver</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># translate src symbol constraints to z3 readable form
</span>            <span class="n">z3_r_cond</span> <span class="o">=</span> <span class="n">Translator</span><span class="p">.</span><span class="n">to_language</span><span class="p">(</span><span class="s">'z3'</span><span class="p">).</span><span class="n">from_expr</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
        <span class="k">except</span> <span class="nb">NotImplementedError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># translate dst symbol constraints to z3 readable form
</span>            <span class="n">z3_l_cond</span> <span class="o">=</span> <span class="n">Translator</span><span class="p">.</span><span class="n">to_language</span><span class="p">(</span><span class="s">'z3'</span><span class="p">).</span><span class="n">from_expr</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
        <span class="k">except</span> <span class="nb">NotImplementedError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c1"># add equality condition to solver
</span>        <span class="n">solver</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">z3</span><span class="p">.</span><span class="n">Not</span><span class="p">(</span><span class="n">z3_r_cond</span> <span class="o">==</span> <span class="n">z3_l_cond</span><span class="p">))</span>

        <span class="c1"># if condition was unsatisfiable
</span>        <span class="n">r</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">check</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">z3</span><span class="p">.</span><span class="n">unsat</span><span class="p">:</span>
            <span class="c1"># IR expression were equivalent
</span>            <span class="c1"># keep iterating
</span>            <span class="k">continue</span>

    <span class="p">...</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>After this we will have a list of all function’s blocks evaluation with each other in terms of syntactic and semantic equivalence:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="p">...</span>

<span class="c1"># save results of syntax and semantic checks
</span><span class="n">results</span><span class="p">[(</span><span class="n">src_ldl</span><span class="p">,</span> <span class="n">dst_ldl</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r_syntax</span><span class="p">,</span> <span class="n">r_semantic</span><span class="p">)]</span>

<span class="p">...</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>Having this we can create a graph based on this relationship and utilize it to mark the equivalent blocks in a given subject function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="rouge-code"><pre>
<span class="p">...</span>

    <span class="c1"># create graph
</span>    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="c1"># add nodes
</span>    <span class="n">G</span><span class="p">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">target_blocks</span><span class="p">)</span>

    <span class="c1"># add edges based on syntax/semantic equivalence
</span>    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">viewitems</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
        <span class="c1"># if blocks have syntactic or semantic equivalence
</span>        <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># add edge on block labels
</span>            <span class="n">G</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">random_colors</span> <span class="o">=</span> <span class="n">gen_random_color</span><span class="p">()</span>
    <span class="n">body</span> <span class="o">=</span> <span class="s">''</span>

    <span class="c1"># Iterate through the blocks which are equivalent
</span>    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">conn_nodes</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nx</span><span class="p">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)):</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conn_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">conn_nodes</span><span class="p">:</span>  <span class="c1"># node is asmblk
</span>            <span class="c1"># set the same color for equivalent nodes
</span>            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">LocKey</span><span class="p">):</span>
                <span class="n">asmblk</span> <span class="o">=</span> <span class="n">asmcfg</span><span class="p">.</span><span class="n">loc_key_to_block</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">asmblk</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">asmblk</span><span class="p">.</span><span class="n">lines</span><span class="p">:</span>
                        <span class="n">body</span> <span class="o">+=</span> <span class="s">'SetColor(0x%08x, CIC_ITEM, 0x%x);</span><span class="se">\n</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">random_colors</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">node</span><span class="p">.</span><span class="n">lines</span><span class="p">:</span>
                    <span class="n">body</span> <span class="o">+=</span> <span class="s">'SetColor(0x%08x, CIC_ITEM, 0x%x);</span><span class="se">\n</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">random_colors</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

    <span class="n">header</span> <span class="o">=</span> <span class="s">'''
#include &lt;idc.idc&gt;
static main()
{
'''</span>
    <span class="n">footer</span> <span class="o">=</span> <span class="s">'''
}
'''</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'eq-color.idc'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span>
    <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span> <span class="o">+</span> <span class="n">body</span> <span class="o">+</span> <span class="n">footer</span><span class="p">)</span>
    <span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The full script can be downloaded <a href="https://github.com/ulexec/ulexec.github.io/raw/master/files/range_divider_detector.py">here</a></p>

<p>After applying the previous script to a given obfuscated function (0x10009B82) and slightly refine the results, we can obtain the following:</p>

<div align="center">
<img src="/images/asprox_range_divider.png" style="width: 100%; height: auto;" />
</div>

<p>After this is trivial to remove the range divider predicates from the subject function. All we need is to identify the initial conditional branch that diverges into each individual predicate and apply the correspondent chnages to it appropietly.
The following are the before and after effects:</p>

<div align="center">
<img src="/images/asprox_range_divider2.png" style="width: 100%; height: auto;" />
</div>

<p>In the particular case of Asprox I found that it wasn’t implementing a high number of Range Divider predicates, usually two. Therefore it was trivial to clean the code after identifying them.
All needed to do was to either patch the intial conditional branch that diverges into each individual predicate so that it becomes unconditional or patch the conditional branch in a way so that it becomes NOPed.
We can apply either of these approaches accordingly to chose the predicate that will drive the control flow and remove the remaining ones.</p>

<p>Is also important to emphasize that the Range Divider cleaning process may not be as trivial if higher numbers of predicates where encountered or if the structure of the predicates would make each predicate to overlap with one another. Also lets not forget that this approach is assuming that the correct comparison unit is a basic block, which is true for Asprox predicates but is not necessarily generic. For example Tigress obfuscator implements Range Divider predicates on a function granuality. Therefore, this approach wont work, but could be adapted to support Tigress predicates re-defining the granuality for comparison and equivalence computation.</p>

<p>To finish this section on a high note, we can see that by marking blocks from a given function based on syntax and semantic equivalence can help us to indentify this obfuscation technique.</p>

<p>Last but not least, I would like to give a shout out to Mr Yuma Kurogome to be kind enough to make the content of this course public.</p>

        </div>
        
        <style>
        /* Text formatting and indentation */
        .container article p {
            margin-bottom: 1.5rem !important;
            text-indent: 0 !important;
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
        }
        
        .container article blockquote {
            border-left: 4px solid #10ebff !important;
            padding-left: 1.5rem !important;
            margin: 1.5rem 0 !important;
            font-style: italic !important;
            opacity: 0.9 !important;
        }
        
        .container article ul {
            margin: 1.5rem 0 !important;
            padding-left: 2rem !important;
        }
        
        .container article ol {
            margin: 1.5rem 0 !important;
            padding-left: 2rem !important;
        }
        
        .container article ol li {
            padding-left: 0.5rem !important;
        }
        
        .container article ul li {
            padding-left: 0.5rem !important;
        }
        
        .container article li {
            margin-bottom: 0.5rem !important;
            line-height: 1.6 !important;
        }
        
        .container article h2, .container article h3, .container article h4 {
            margin-top: 2.5rem !important;
            margin-bottom: 1rem !important;
            color: #10ebff !important;
        }
        
        /* Better hyperlink colors for blog content */
        .container article a {
            color: #10ebff !important;
            text-decoration: none !important;
            transition: all 0.3s ease !important;
            border-bottom: 1px solid rgba(16, 235, 255, 0.3) !important;
        }
        
        .container article a:hover {
            color: #35e4f4 !important;
            border-bottom-color: rgba(53, 228, 244, 0.8) !important;
            text-shadow: 0 0 8px rgba(16, 235, 255, 0.3) !important;
        }
        
        .container article a:visited {
            color: #8b5cf6 !important;
            border-bottom-color: rgba(139, 92, 246, 0.3) !important;
        }
        
        .container article a:visited:hover {
            color: #a78bfa !important;
            border-bottom-color: rgba(167, 139, 250, 0.8) !important;
        }
        
        /* Override link styles specifically for back button */
        .container article .back-to-blog-button,
        .container article .back-to-blog-button:link,
        .container article .back-to-blog-button:visited,
        .container article .back-to-blog-button:active,
        .container article .back-to-blog-button:hover {
            color: #ffffff !important;
            border-bottom: none !important;
        }
        
        /* Back to blog button with gradient theme */
        .back-to-blog-button,
        .back-to-blog-button:link,
        .back-to-blog-button:visited,
        .back-to-blog-button:active {
            display: inline-block !important;
            margin-top: 4rem !important;
            padding: 12px 24px !important;
            background: linear-gradient(135deg, rgba(16, 235, 255, 0.1) 0%, rgba(185, 26, 238, 0.1) 100%) !important;
            color: #ffffff !important;
            text-decoration: none !important;
            border-radius: 8px !important;
            font-weight: 400 !important;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1) !important;
            font-size: 0.95rem !important;
            border: 1px solid transparent !important;
            position: relative !important;
            overflow: hidden !important;
            font-family: 'Raleway', system-ui, sans-serif !important;
            border-bottom: none !important;
        }
        
        .back-to-blog-button::before {
            content: '' !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            background: linear-gradient(90deg, #10ebff, #b91aee) !important;
            opacity: 0 !important;
            transition: opacity 0.3s ease !important;
            border-radius: 8px !important;
            z-index: -1 !important;
            padding: 1px !important;
            margin: -1px !important;
        }
        
        .back-to-blog-button:hover::before {
            opacity: 0.6 !important;
        }
        
        .back-to-blog-button:hover,
        .back-to-blog-button:hover:link,
        .back-to-blog-button:hover:visited,
        .back-to-blog-button:hover:active {
            color: #ffffff !important;
            transform: translateY(-2px) !important;
            box-shadow: 0 8px 25px rgba(16, 235, 255, 0.2), 0 0 20px rgba(185, 26, 238, 0.1) !important;
            background: linear-gradient(135deg, rgba(16, 235, 255, 0.15) 0%, rgba(185, 26, 238, 0.15) 100%) !important;
            border-bottom: none !important;
        }
        </style>
        
        <!-- Enhanced back button with gradient theme -->
        <a href="/blog/" class="back-to-blog-button">← Back to Blog</a>
    </article>
</div>

<style>
@keyframes shimmerTitle {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
}

/* Enhanced code block styling */
.container article code {
    background: rgba(16, 235, 255, 0.1) !important;
    border: 1px solid rgba(16, 235, 255, 0.2) !important;
    color: #10ebff !important;
    padding: 0.2rem 0.4rem !important;
    border-radius: 4px !important;
    font-family: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', Consolas, monospace !important;
    font-size: 0.9rem !important;
    font-weight: 500 !important;
}

.container article pre {
    background: rgba(0, 0, 0, 0.4) !important;
    border: 1px solid rgba(59, 130, 246, 0.2) !important;
    border-radius: 8px !important;
    padding: 1.5rem !important;
    margin: 2rem 0 !important;
    overflow-x: auto !important;
    font-size: 0.9rem !important;
    line-height: 1.5 !important;
}

.container article pre code {
    background: none !important;
    border: none !important;
    padding: 0 !important;
    color: #e5e7eb !important;
    font-size: inherit !important;
}

.container article .highlight {
    background: rgba(0, 0, 0, 0.4) !important;
    border: 1px solid rgba(59, 130, 246, 0.25) !important;
    border-radius: 8px !important;
    margin: 2rem 0 !important;
    overflow: hidden !important;
    font-size: 0.9rem !important;
}

.container article .highlight pre {
    background: none !important;
    border: none !important;
    padding: 1.5rem !important;
    margin: 0 !important;
    overflow-x: auto !important;
}

.container article .highlight code {
    background: none !important;
    border: none !important;
    padding: 0 !important;
    color: #e5e7eb !important;
    font-size: inherit !important;
}

/* Hide line numbers */
.container article .highlight .lineno,
.container article .highlight .gutter,
.container article .highlight .gutter .lineno {
    display: none !important;
}

.container article .highlight table {
    border: none !important;
    background: none !important;
}

.container article .highlight table td {
    border: none !important;
    background: none !important;
    padding: 0 !important;
}

.container article .highlight table .code {
    padding: 0 !important;
}

/* Custom scrollbar styling for code blocks - black theme */
.container article pre::-webkit-scrollbar,
.container article .highlight::-webkit-scrollbar {
    height: 8px !important;
    background: rgba(0, 0, 0, 0.9) !important;
    border-radius: 4px !important;
}

.container article pre::-webkit-scrollbar-thumb,
.container article .highlight::-webkit-scrollbar-thumb {
    background: rgba(40, 40, 40, 0.9) !important;
    border-radius: 4px !important;
    border: 1px solid rgba(80, 80, 80, 0.5) !important;
}

.container article pre::-webkit-scrollbar-thumb:hover,
.container article .highlight::-webkit-scrollbar-thumb:hover {
    background: rgba(60, 60, 60, 0.9) !important;
    border-color: rgba(100, 100, 100, 0.7) !important;
}

.container article pre::-webkit-scrollbar-track,
.container article .highlight::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.9) !important;
    border-radius: 4px !important;
}

/* Firefox scrollbar styling - black theme */
.container article pre,
.container article .highlight {
    scrollbar-width: thin !important;
    scrollbar-color: rgba(40, 40, 40, 0.9) rgba(0, 0, 0, 0.9) !important;
}

/* Responsive styles for mobile */
@media (max-width: 768px) {
    /* Post title - add top padding and reduce size */
    .container article h1 {
        font-size: 2rem !important;
        padding-top: 2rem !important;
        margin-bottom: 1rem !important;
    }
    
    /* Force all code elements to same size - very aggressive approach */
    .container article pre *,
    .container article .highlight *,
    .container article code,
    .container article pre,
    .container article .highlight,
    .container article .highlight pre,
    .container article .highlight code,
    .container article .highlight table *,
    .container article .highlight .gutter *,
    .container article .highlight .code *,
    .container article p code,
    .container article li code,
    .container article td code,
    .container article h1 code,
    .container article h2 code,
    .container article h3 code,
    .container article h4 code {
        font-size: 0.7rem !important;
        line-height: 1.3 !important;
    }
    
    /* Code block containers - uniform padding */
    .container article pre,
    .container article .highlight {
        padding: 0.8rem !important;
        margin: 1rem 0 !important;
    }
}
</style>

<script>
// Nuclear option - force ALL code to be uniform on mobile
function fixMobileCodeFonts() {
    if (window.innerWidth <= 768) {
        // Get EVERY element that might contain code
        const allElements = document.querySelectorAll('*');
        
        allElements.forEach(element => {
            // Check if element is code-related
            if (element.tagName === 'CODE' || 
                element.tagName === 'PRE' || 
                element.classList.contains('highlight') ||
                element.classList.contains('language-plaintext') ||
                element.classList.contains('highlighter-rouge') ||
                element.className.includes('language-') ||
                element.className.includes('highlight')) {
                
                // Force the font size
                element.style.setProperty('font-size', '0.6rem', 'important');
                element.style.setProperty('line-height', '1.2', 'important');
                
                // Also check all children
                const children = element.querySelectorAll('*');
                children.forEach(child => {
                    child.style.setProperty('font-size', '0.6rem', 'important');
                    child.style.setProperty('line-height', '1.2', 'important');
                });
            }
        });
    }
}

// Run on page load
document.addEventListener('DOMContentLoaded', fixMobileCodeFonts);

// Run on window resize
window.addEventListener('resize', fixMobileCodeFonts);

// Run again after a short delay to catch any dynamically loaded content
setTimeout(fixMobileCodeFonts, 100);
</script>
    </main>

    <footer>
    <div class="container">
        <img src="/images/logo.svg" width="350" alt="Inversive Labs Logo" />
        <p>&copy; 2025 Inversive Labs</p>
    </div>
</footer>

    <script src="/assets/js/shader-background.js"></script>
    <script src="/assets/js/site.js"></script>
</body>
</html>